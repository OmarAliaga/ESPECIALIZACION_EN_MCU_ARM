/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "RCC.h"

/**
 * USE_DELAY_US
 * 0 : solo retardos en milisegundos
 * 1 : retardos en microsegundos/milisegundos
 */
#define USE_DELAY_US  1


/**
 * OUTPUT MODE
 */
#define GPIO_OUTPUT(GPIOx,PIN){ GPIOx->MODER &=~ (1U<<2*PIN);\
								GPIOx->MODER |= 1U<<2*PIN;\
								GPIOx->OTYPER &=~ (1U<<PIN);\
								GPIOx->OSPEEDR |= 0x3U<<PIN*2;\
								GPIOx->PUPDR &=~ (0x3U<<PIN*2);}
#if USE_DELAY_US == 1

/**
 * @brief funcion que va generar retardos en microsegundos
 */
void delay_us(uint32_t delay);
#endif
/**
 * delay init
 * @param [ticks] : obtenido de la formula ticks = SystemCoreClock * T(s)
 */
void delay_Init(uint32_t ticks);
/**
 * @brief funcion que va generar retardos en milisegundos
 */
void delay_ms(uint32_t delay);

int main(void)
{
	/*pll init*/
//	flash_cofig();
//	PLL_Config();

	/*delay init*/
#if USE_DELAY_US == 1
	delay_Init(SystemCoreClock/1000000);
#else
	delay_Init(SystemCoreClock/1000);
#endif

	/*enable clk*7	 */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	//PA5 -> SALIDA DIGITAL (push-pull, verry high speed)
	GPIO_OUTPUT(GPIOA,5);

    /* Loop forever */
	for(;;){
		GPIOA->ODR ^= 1U<<5;
		delay_us(50);
	}
}

#if USE_DELAY_US == 1
/**
 * @brief funcion que va generar retardos en microsegundos
 */
void delay_us(uint32_t delay){
	uint32_t i;
	/*poner el regitro VAL*/
	SysTick->VAL = 0;
	for(i = 0;i<delay;i++){
		while(!(SysTick->CTRL & 1U<<16));			//retardo de un microsegundo
	}
	return;

}


#endif
/**
 * delay init
 */
void delay_Init(uint32_t ticks){
	/*deshabilitar la systick*/
	SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
	/*cargar el valor de reload al registro LOAD*/
	SysTick->LOAD = ticks - 1;   //2^24 - SystemCoreClock * delay/1000
	/*selecciona la fuente de reloj*/
	SysTick->CTRL |= 1u<<2;
	/*elegir la fuente de reloj Habilitar el conteo*/
	SysTick->CTRL |=  1;				//SYSCLK
}
/**
 * @brief funcion que va generar retardos en milisegundos
 */
void delay_ms(uint32_t delay){
	uint32_t i;
#if USE_DELAY_US == 1
	for(i = 0;i<delay;i++){
		delay_us(1000);
	}
#else
	/*deshabilitar la systick*/
//	SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
//	/*cargar el valor de reload al registro LOAD*/
//	SysTick->LOAD = 84000 - 1;   //2^24 - SystemCoreClock * delay/1000

	/*poner el regitro VAL*/
	SysTick->VAL = 0;
//
//	/*elegir la fuente de reloj*/
//	SysTick->CTRL |= 1u<<2;				//SYSCLK
	/*Habilitar el conteo*/
	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;

	for(i = 0;i<delay;i++){
		while(!(SysTick->CTRL & 1U<<16));			//retardo de un milisegundo
	}

//	/*deshabilitar la systick*/
//	SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
#endif
	return;
}



/*****************************************************************/

int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	ITM_SendChar(c);
	return ch;
}

