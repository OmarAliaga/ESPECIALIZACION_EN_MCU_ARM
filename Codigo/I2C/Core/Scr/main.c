/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
/* Private includes ----------------------------------------------------------*/
#include "RCC.h"
#include "Config.h"
/* Private typedef -----------------------------------------------------------*/


/* Private define ------------------------------------------------------------*/


/* Private macro -------------------------------------------------------------*/
#define USE_SWV			0

#define I2C1_SCL		B, 8
#define I2C1_SDA		B, 9
#define PCLK1			16E+6
#define SLAVE_ADDR  	0x60
/* Private variables ---------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/


/* Private user code ---------------------------------------------------------*/

/**
 * @brief configuracion de pines para el i2c1
 */
void I2C1_GPIOInit(void);
/**
 * @brief configura el i2c
 */
void I2C1_Init(I2C_TypeDef *I2Cx);
/* External variables --------------------------------------------------------*/


int main(void)
{

	/*LED INIT*/

    /* Loop forever */
	for(;;){



	}
}

/**
 * @brief configuracion de pines para el i2c1
 */
void I2C1_GPIOInit(void){
	/*enable clock*/
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL) | GPIOX_CLOCK(I2C1_SDA);
	//PB9->I2C1_SDA, PB8->I2C1_SCL
	GPIOX_MODER(MODE_ALTER,I2C1_SCL);
	GPIOX_MODER(MODE_ALTER,I2C1_SDA);
	GPIOX_OTYPER(MODE_OT_OD,I2C1_SCL);
	GPIOX_OTYPER(MODE_OT_OD,I2C1_SDA);
	GPIOX_PUPDR(MODE_PU_UP,I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP,I2C1_SDA);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,I2C1_SDA);
	GPIOX_AFR(4,I2C1_SCL);
	GPIOX_AFR(4,I2C1_SDA);
}


/**
 * @brief configura el i2c
 */
void I2C1_Init(I2C_TypeDef *I2Cx){
	uint32_t tempreg = 0;
	uint16_t ccr_value = 0;
	/*habilitar el reloj*/
	if(I2Cx == I2C1)
		RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	else if(I2Cx == I2C2)
		RCC->APB1ENR |= RCC_APB1ENR_I2C2EN;
	else
		RCC->APB1ENR |= RCC_APB1ENR_I2C3EN;
	/*entrar en modo reset*/
	I2Cx->CR1 |= 1U<<15;
	/*salir del modo reset*/
	I2Cx->CR1 &=~ (1U<<15);

	//ack control bit
	I2Cx->CR1 = I2C_CR1_ACK;

	//configuramos el campo FREQ del registro CR2
	tempreg = PCLK1 / 1000000U;
	I2Cx->CR2 = (tempreg & 0x3FU);

	//direccion esclavo (solo en caso de que el i2c trabaje en modo esclavo)
	tempreg = SLAVE_ADDR<<1;
	tempreg |= (1<<14);
	I2Cx->OAR1 = tempreg;
	//calculo de CCR
	tempreg = 0;
	ccr_value = (PCLK1 / (2 * 100000));
	tempreg = (ccr_value & 0xFFF);
	//tempreg |= I2C_CCR_FS;
	//ccr_value = (PCLK1 / ( 3 * 400000)); //SI DUTY == 0
	//ccr_value = (PCLK1 / (25 * I2C_SCL_SPEED_FM4K)); //SI DUTY == 1
	I2Cx->CCR = tempreg;
	//cofigurar el TRISE
	tempreg = (PCLK1 / 1000000U) + 1;
	//tempreg = ( (PCLK1 * 300) / 1000000000U ) + 1; //FAST MODE
	I2Cx->TRISE = (tempreg & 0x3F);

	return;
}
/******************************************************************************/
int __io_putchar(int ch){
#if (USE_SWV== 1)
	ITM_SendChar((uint32_t)ch);
#endif
	return ch;
}
